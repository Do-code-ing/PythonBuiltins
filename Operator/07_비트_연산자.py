# 비트 연산자 (Bitwise Operator)
# 비트 단위에서 작동하는 연산자다.

# 두 피연산자의 비트 값이 같은 부분 : Binary AND(&)
# 교집합이라고 이해하면 좋다.
print(2 & 3)
# 2
# 각각 2진수로 나타내면,
# 2 = 0010, 3 = 0011 이다. (앞의 0은 이해를 돕기위해 첨가)
# 같은 부분은 10진법으로 10의 자리인 수 1이 같기 때문에
# 10이 같은 부분이라고 판단하여,
# 2진수 10의 10진수는 2이기에 2가 나온다.
print(4 & 5)
# 4
# 0100 & 0101 = 0100 -> 4
print(2 & 8)
# 0
# 0010 & 1000 = 0000 -> 0

# 아래의 표를 보고 나머지도 이해해 보자
# 2 = 0010
# 3 = 0011
# 4 = 0100
# 5 = 0101
# 6 = 0110
# 7 = 0111
# 8 = 1000

# 두 피연산자의 비트 값의 합집합 : Binary OR(|)
print(2 | 3)
# 3
# 0010 | 0011 = 0011 -> 3
print(2 | 8)
# 10
# 0010 | 1000 = 1010 -> 10

# 두 피연산자의 비트 값의 대칭차집합 : Binary XOR(^)
# XOR : (exclusive-OR : 배타적 논리합)
print(2 ^ 3)
# 1
# 0010 ^ 0011 = 0001 -> 1
print(7 ^ 8)
# 15
# 0111 ^ 1000 = 1111 -> 15

# 피연산자의 비트 보수 값 : Binary One’s Complement(~)
# 간단한 예를 들어, 정수 x의 비트 보수를 표현하는 과정은
# ~x == -1 * x - 1 과 같다.
print(~2)
# -3
print(~8)
# -9

# 이해가 잘 안되는 부분인데, 비트에 대한 이해도가 필요해보인다.

# 첫 피연산자의 비트를 두 번째 피연산자의 비트의 자릿 수 만큼 왼쪽으로 이동 : Binary Left-Shift(<<)
print(2 << 2)
# 8
# 첫 피연산자의 비트 10을, 두 번째 피연산자의 비트 10이 두 자리 이므로, 두 자리 만큼 왼쪽으로 이동,
# 즉 00'10' -> '10'00 = 8

# 첫 피연산자의 비트를 두 번째 피연산자의 비트의 자릿 수 만큼 오른쪽으로 이동 : Binary Right-Shift(>>)
print(8 >> 1)
# 4
# 첫 피연산자의 비트 100을, 두 번째 피연산자의 비트 1이 한 자리 이므로, 한 자리 만큼 오른쪽으로 이동,
# 즉 '1000' -> 0'100' = 4

